#pragma config(Sensor, S1,     in1,            sensorTouch)
#pragma config(Motor,  port1,           motorLeft,    tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  port2,           motorRight,   tmotorNormal, PIDControl, encoder)

#define PI 3.14159265359

// Function to calculate the angle between two points
float calculateAngle(int x1, int y1, int x2, int y2) {
  if (x1 == x2) {
    // If points are vertical
    return (y2 > y1) ? PI / 2 : -PI / 2;
  } 
  else if (y1 == y2) {
    // If points are horizontal
    return (x2 < x1) ? PI : 0;
  } 
  else {
    // General case for diagonal movement
    return atan2(abs(y2 - y1), abs(x2 - x1));
  }
}

// Function to calculate direction using the cross product of vectors
string calculateDirection(int x1, int y1, int x2, int y2, int x3, int y3) {
  // Cross product of vectors (p2 - p1) and (p3 - p2)
  int vector1X = x2 - x1;
  int vector1Y = y2 - y1;
  int vector2X = x3 - x2;
  int vector2Y = y3 - y2;

  int crossProduct = vector1X * vector2Y - vector1Y * vector2X;
  
  if (crossProduct > 0) {
    return "CCW";  // Counter Clockwise
  } 
  else if (crossProduct < 0) {
    return "CW";   // Clockwise
  } 
  else {
    return "Collinear"; // No rotation, points are collinear
  }
}

task main() {
  int numPoints = 6;
  int points[6][2] = {
    {-5, 0},  // Point 1
    {0, -1},  // Point 2
    {-6, -3}, // Point 3
    {3, 3},   // Point 4
    {3, 5},   // Point 5
    {9, 4}    // Point 6
  };

  float accumulatedAngle = 0;

  // Display initial instructions
  displayTextLine(0, "Angle Calculation:");

  // Loop through the points and calculate angles and direction
  for (int i = 1; i < numPoints - 1; i++) {
    float angle = calculateAngle(points[i - 1][0], points[i - 1][1], points[i][0], points[i][1]);
    accumulatedAngle += angle;

    string direction = calculateDirection(points[i - 1][0], points[i - 1][1], points[i][0], points[i][1], points[i + 1][0], points[i + 1][1]);
    
    // Display results for each pair of points
    displayTextLine(i, "Angle %d->%d: %.2f deg", i, i + 1, angle * 180 / PI);
    displayTextLine(i + 1, "Direction: %s", direction);
    displayTextLine(i + 2, "Acc. Angle: %.2f deg", accumulatedAngle * 180 / PI);

    // Add a small delay to allow the user to see the output on screen
    wait1Msec(1000);
  }

  // Display the total accumulated angle at the end
  displayTextLine(6, "Total Accumulated Angle:");
  displayTextLine(7, "%.2f deg", accumulatedAngle * 180 / PI);
}
